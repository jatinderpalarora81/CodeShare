import cx_Oracle
import csv
import sys

def connect_and_query(username, password, db_host, db_port, service_name):
    try:
        # Create a connection to the Oracle database
        dsn_tns = cx_Oracle.makedsn(db_host, db_port, service_name=service_name)
        connection = cx_Oracle.connect(user=username, password=password, dsn=dsn_tns)

        # Create a cursor to execute SQL queries
        cursor = connection.cursor()

        # Execute the SELECT query
        query = "SELECT * FROM employee"
        cursor.execute(query)

        # Fetch all the rows returned by the query
        rows = cursor.fetchall()

        # Close the cursor and connection
        cursor.close()
        connection.close()

        return rows

    except cx_Oracle.DatabaseError as e:
        print("Error connecting to Oracle database:", e)
        return None

def write_to_csv(file_name, rows):
    if rows is None:
        return

    try:
        with open(file_name, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            # Write the header
            writer.writerow(["Employee ID", "Employee Name", "Salary", "Department"])

            # Write each row to the CSV file
            for row in rows:
                writer.writerow(row)

        print(f"Data written to '{file_name}' successfully.")
    except IOError as e:
        print("Error writing to CSV:", e)

if __name__ == "__main__":
    if len(sys.argv) != 6:
        print("Usage: python script_name.py username password db-host db-port service_name")
    else:
        username = sys.argv[1]
        password = sys.argv[2]
        db_host = sys.argv[3]
        db_port = sys.argv[4]
        service_name = sys.argv[5]

        result_rows = connect_and_query(username, password, db_host, db_port, service_name)

        if result_rows:
            output_csv_file = "employee_data.csv"
            write_to_csv(output_csv_file, result_rows)



import json

def calculate_hash(data):
    """Calculate a hash code using the built-in hash() function."""
    data_str = json.dumps(data, sort_keys=True)
    hash_code = hash(data_str)
    return hash_code

def save_hash_to_file(hash_code, filename):
    """Save the hash code to a text file."""
    with open(filename, 'w') as file:
        file.write(str(hash_code))

def read_hash_from_file(filename):
    """Read the hash code from a text file."""
    try:
        with open(filename, 'r') as file:
            return int(file.read().strip())
    except FileNotFoundError:
        return None

def compare_and_update_hash(data, filename):
    """Compare the hash code of the data with the one stored in the file.
    If different, update the hash code in the file and return True.
    Otherwise, return False.
    """
    current_hash = calculate_hash(data)
    stored_hash = read_hash_from_file(filename)
    
    if stored_hash is None or current_hash != stored_hash:
        save_hash_to_file(current_hash, filename)
        return True
    else:
        return False

# Example usage
data = {"key1": "value1", "key2": "value2"}
json_file = "data.json"
hash_file = "hash.txt"

# Calculate and store hash code in a text file
save_hash_to_file(calculate_hash(data), hash_file)

# Compare and update hash code if necessary
if compare_and_update_hash(data, hash_file):
    print("Hash code updated.")
else:
    print("Hash code unchanged.")


Copy code
import json
import hashlib

def calculate_file_hash(file_path):
    """Calculate a hash code for a given file using SHA-256."""
    block_size = 65536  # 64KB blocks
    hash_object = hashlib.sha256()

    with open(file_path, 'rb') as file:
        while True:
            data = file.read(block_size)
            if not data:
                break
            hash_object.update(data)

    return hash_object.hexdigest()

def delete_json_file(file_path):
    """Delete a JSON file at the given path."""
    if os.path.exists(file_path):
        try:
            os.remove(file_path)
            print(f"{file_path} deleted successfully.")
        except Exception as e:
            print(f"Error deleting {file_path}: {e}")
    else:
        print(f"{file_path} does not exist.")
